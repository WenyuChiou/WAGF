from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional
import math


@dataclass
class DriftReport:
    """Population-level drift analysis."""
    year: int
    entropy: float
    dominant_action: str
    dominant_pct: float
    type_distributions: Dict[str, Dict[str, int]]
    alerts: List[str]


@dataclass
class AgentDriftReport:
    """Individual agent drift analysis."""
    agent_id: str
    jaccard_score: float
    construct_changes: int
    decision_variety: int
    stagnant: bool
    alert: Optional[str] = None


@dataclass
class DriftAlert:
    """Alert generated by drift detection."""
    year: int
    level: str
    category: str
    message: str
    details: Dict[str, Any] = field(default_factory=dict)


class DriftDetector:
    def __init__(self, window_size=5, entropy_threshold=0.5, jaccard_threshold=0.7):
        self.window_size = window_size
        self.entropy_threshold = entropy_threshold
        self.jaccard_threshold = jaccard_threshold
        self.decision_history: Dict[str, List[str]] = {}
        self.construct_history: Dict[str, List[Dict[str, str]]] = {}
        self.population_snapshots: List[Dict[str, Any]] = []

    # --- Population-level ---
    def record_population_snapshot(
        self,
        year: int,
        decisions: Dict[str, str],
        agent_types: Optional[Dict[str, str]] = None
    ) -> None:
        """Record decision distribution for a year."""
        distribution: Dict[str, int] = {}
        for decision in decisions.values():
            distribution[decision] = distribution.get(decision, 0) + 1

        type_distributions: Dict[str, Dict[str, int]] = {}
        if agent_types:
            for agent_id, decision in decisions.items():
                a_type = agent_types.get(agent_id, "unknown")
                type_distributions.setdefault(a_type, {})
                type_distributions[a_type][decision] = type_distributions[a_type].get(decision, 0) + 1

        self.population_snapshots.append({
            "year": year,
            "distribution": distribution,
            "type_distributions": type_distributions,
        })

    @staticmethod
    def compute_shannon_entropy(distribution: Dict[str, int]) -> float:
        """Compute Shannon entropy of a decision distribution."""
        total = sum(distribution.values())
        if total == 0:
            return 0.0
        entropy = 0.0
        for count in distribution.values():
            if count > 0:
                p = count / total
                entropy -= p * math.log2(p)
        return entropy

    def detect_population_drift(self) -> Optional[DriftReport]:
        """Analyze latest snapshot."""
        if not self.population_snapshots:
            return None
        snapshot = self.population_snapshots[-1]
        distribution = snapshot.get("distribution", {})
        type_distributions = snapshot.get("type_distributions", {})
        if not distribution:
            return None

        entropy = self.compute_shannon_entropy(distribution)
        dominant_action = max(distribution, key=distribution.get)
        dominant_pct = distribution[dominant_action] / sum(distribution.values())

        alerts = []
        if entropy < self.entropy_threshold:
            alerts.append(f"Entropy below threshold: {entropy:.2f}")
        if dominant_pct >= 0.8:
            alerts.append(f"Dominant action exceeds 80%: {dominant_action} ({dominant_pct:.0%})")
        for a_type, dist in type_distributions.items():
            if len(dist) == 1 and sum(dist.values()) > 1:
                alerts.append(f"Uniform decisions for type {a_type}")

        return DriftReport(
            year=snapshot["year"],
            entropy=entropy,
            dominant_action=dominant_action,
            dominant_pct=dominant_pct,
            type_distributions=type_distributions,
            alerts=alerts,
        )

    # --- Individual-level ---
    def record_agent_decision(
        self,
        agent_id: str,
        decision: str,
        constructs: Optional[Dict[str, str]] = None
    ) -> None:
        """Record an agent's decision and PMT constructs for the current year."""
        self.decision_history.setdefault(agent_id, []).append(decision)
        if constructs is not None:
            self.construct_history.setdefault(agent_id, []).append(constructs)

    def compute_jaccard_similarity(self, agent_id: str) -> float:
        """Jaccard similarity of recent decisions within window."""
        history = self.decision_history.get(agent_id, [])
        if len(history) < 2:
            return 0.0
        window = history[-self.window_size:]
        unique = set(window)
        if not window:
            return 0.0
        return 1.0 - (len(unique) / len(window))

    def detect_individual_drift(self, agent_id: str) -> Optional[AgentDriftReport]:
        """Check individual agent for stagnation."""
        history = self.decision_history.get(agent_id, [])
        if not history:
            return None
        window = history[-self.window_size:]
        unique = set(window)
        jaccard = self.compute_jaccard_similarity(agent_id)
        stagnant = jaccard > self.jaccard_threshold

        construct_changes = 0
        constructs = self.construct_history.get(agent_id, [])
        if constructs:
            window_constructs = constructs[-self.window_size:]
            for prev, curr in zip(window_constructs, window_constructs[1:]):
                if prev != curr:
                    construct_changes += 1

        alert = "Agent decisions stagnant" if stagnant else None
        return AgentDriftReport(
            agent_id=agent_id,
            jaccard_score=jaccard,
            construct_changes=construct_changes,
            decision_variety=len(unique),
            stagnant=stagnant,
            alert=alert,
        )

    # --- Alerts ---
    def get_alerts(self, year: int) -> List[DriftAlert]:
        """Run all checks and return any alerts."""
        alerts: List[DriftAlert] = []
        report = self.detect_population_drift()
        if report:
            for msg in report.alerts:
                category = "population"
                if "Uniform decisions for type" in msg:
                    category = "type"
                alerts.append(DriftAlert(
                    year=year,
                    level="WARNING",
                    category=category,
                    message=msg,
                    details={"entropy": report.entropy, "dominant_pct": report.dominant_pct},
                ))

        for agent_id in self.decision_history.keys():
            rep = self.detect_individual_drift(agent_id)
            if rep and rep.stagnant:
                alerts.append(DriftAlert(
                    year=year,
                    level="WARNING",
                    category="individual",
                    message=rep.alert or "Agent stagnation detected",
                    details={"agent_id": agent_id, "jaccard_score": rep.jaccard_score},
                ))

        return alerts

    def summary(self) -> Dict[str, Any]:
        """Return summary statistics."""
        latest = self.population_snapshots[-1] if self.population_snapshots else {}
        return {
            "population_snapshots": len(self.population_snapshots),
            "agents_tracked": len(self.decision_history),
            "latest_year": latest.get("year"),
        }
